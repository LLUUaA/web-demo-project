<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video</title>
  </head>
  <body>
    <video
      id="video"
      controls
      autoplay
      src="http://hls.cntv.lxdns.com/asp/hls/main/0303000a/3/default/978a64ddd3a1caa85ae70a23414e6540/main.m3u8"
    ></video>
  </body>

  <script src="./utils/mux.min.js"></script>
  <script>
    const util = {
      // 是否是url
      isUrl: (url) => {
        try {
          new URL(url);
          return true;
        } catch (error) {
          return false;
        }
      },
      // 获取url相关信息
      getUrlInfos: (url) => {
        try {
          return new URL(url);
        } catch (error) {
          return null;
        }
      },
    };
    // 定义通用的事件回调处理函数，只做打印事件类型
    function logevent(event) {
      console.log(event);
    }
  </script>

  <script>
    const M3U = "m3u";
    const M3U8 = "m3u8";
    const videoEl = document.querySelector("#video");

    // 播放配置
    const playConfig = {
      combined: true,
    };

    let vjsParsed, video, mediaSource;
    // init
    const init = function () {
      const currentSrc = videoEl.currentSrc;
      const srcExt = getSrcExt(currentSrc);
      if (srcExt === M3U || srcExt === M3U8) {
        getM3uResource(currentSrc)
          .then((sourceUrls) => {
            console.log(sourceUrls);
            handlePlay(sourceUrls);
          })
          .catch(console.warn);
      }
    };

    /**
     * @desc 视频播放
     * @params {Array} playList
     * @params {Element} videoEl
     */
    function handlePlay(playList) {
      let buffer, // MediaSource buffer
        offset = 0,
        totalBytesLen = 0, // 字节大小
        playBytes, // 播放bytes
        bytesList = []; // 字节list
      // 转换后mp4的音频格式 视频格式
      const codecsArray = ["avc1.64001f", "mp4a.40.5"];

      // MediaSource Web API: https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource
      // mediaSource = new MediaSource();
      mediaSource = new MediaSource();
      videoEl.src = URL.createObjectURL(mediaSource);
      mediaSource.addEventListener("sourceopen", function () {
        const play = () => {
          // MediaSource 实例默认的duration属性为NaN
          mediaSource.duration = 0;
          // 转换为带音频、视频的mp4
          if (playConfig.combined) {
            buffer = mediaSource.addSourceBuffer(
              'video/mp4;codecs="' + "avc1.64001f,mp4a.40.5" + '"'
            );
          } else if (outputType === "video") {
            // 转换为只含视频的mp4
            buffer = mediaSource.addSourceBuffer(
              'video/mp4;codecs="' + codecsArray[0] + '"'
            );
          } else if (outputType === "audio") {
            // 转换为只含音频的mp4
            buffer = mediaSource.addSourceBuffer(
              'audio/mp4;codecs="' + (codecsArray[1] || codecsArray[0]) + '"'
            );
          }

          // buffer.addEventListener("updatestart", logevent);
          // buffer.addEventListener("updateend", logevent);
          // buffer.addEventListener("error", logevent);
          
          // init playBytes;
          playBytes = new Uint8Array(totalBytesLen);
          offset = 0;
          // set data
          for (let i = 0; i < bytesList.length; i++) {
            playBytes.set(bytesList[i], offset);
            offset += bytesList[i].byteLength;
          }

          // mp4 buffer 准备完毕，传入转换后的数据
          buffer.appendBuffer(playBytes);
        };

        // test
        // playList.splice(0, 15);
        while (playList.length) {
          fetch(playList.splice(0, 1)[0].sourceUrl)
            .then((resp) => resp.arrayBuffer())
            .then(transferFormat)
            .then((bytes) => {
              // console.log('bytes', bytes)
              totalBytesLen += bytes.byteLength;
              bytesList.push(bytes);
              play();
            });
        }

        // 将 bytes 放入 MediaSource 创建的sourceBuffer中
        // https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer
        // 自动播放
        // videoEl.play();
      });
    }

    function transferFormat(data) {
      return new Promise((resolve, reject) => {
        // 将源数据从ArrayBuffer格式保存为可操作的Uint8Array格式
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
        var segment = new Uint8Array(data);
        var combined = playConfig.combined;
        // 接收无音频ts文件，OutputType设置为'video'，带音频ts设置为'combined'
        var outputType = "video";
        var combinedType = "combined";
        var remuxedSegments = [];
        var remuxedBytesLength = 0;
        var remuxedInitSegment = null;

        // remux选项默认为true，将源数据的音频视频混合为mp4，设为false则不混合
        var transmuxer = new muxjs.mp4.Transmuxer({ remux: combined });

        // 监听data事件，开始转换流
        transmuxer.on("data", function (event) {
          console.log("[transmuxer data:]", event);
          if (event.type === outputType || event.type === combinedType) {
            remuxedSegments.push(event);
            remuxedBytesLength += event.data.byteLength;
            remuxedInitSegment = event.initSegment;
          }
        });
        // 监听转换完成事件，拼接最后结果并传入MediaSource
        transmuxer.on("done", function () {
          var offset = 0;
          var bytes = new Uint8Array(
            remuxedInitSegment.byteLength + remuxedBytesLength
          );
          bytes.set(remuxedInitSegment, offset);
          offset += remuxedInitSegment.byteLength;

          for (var j = 0, i = offset; j < remuxedSegments.length; j++) {
            bytes.set(remuxedSegments[j].data, i);
            i += remuxedSegments[j].byteLength;
          }
          remuxedSegments = [];
          remuxedBytesLength = 0;
          // 解析出转换后的mp4相关信息，与最终转换结果无关
          // vjsParsed = muxjs.mp4.tools.inspect(bytes);
          // console.log("transmuxed", vjsParsed);
          resolve(bytes);
        });

        // push方法可能会触发'data'事件，因此要在事件注册完成后调用
        transmuxer.push(segment); // 传入源二进制数据，分割为m2ts包，依次调用上图中的流程
        // flush的调用会直接触发'done'事件，因此要事件注册完成后调用
        transmuxer.flush(); // 将所有数据从缓存区清出来
      });
    }

    /**
     * @desc 获取资源
     * @params {String} txt
     */
    function sourceCanPlay(txt) {
      if (
        txt.indexOf("#EXTINF") !== -1 &&
        txt.indexOf("#EXT-X-ENDLIST") !== -1
      ) {
        return true;
      }
      return false;
    }

    /**
     * @desc 获取资源
     * @params {String} sourceUrl
     */
    function getM3uResource(sourceUrl) {
      return new Promise((resolve, reject) => {
        fetch(sourceUrl)
          .then((response) => {
            // console.log(response);
            response.text().then((t) => {
              if (sourceCanPlay(t)) {
                const playList = parseM3uPlayListTxt(t);
                (playList || []).map((p) => {
                  if (util.isUrl(p.url)) {
                    p.sourceUrl = p.url;
                  } else {
                    p.sourceUrl = sourceUrl.replace(/\d+.m3u8/, p.url); // soruce url
                  }
                  return p;
                });
                resolve(playList);
              } else {
                const sources = parseM3uTxt(t);
                let sUrl;
                const playUrl = sources[1].url;
                if (util.isUrl(playUrl)) {
                  sUrl = playUrl;
                } else {
                  sUrl = util.getUrlInfos(sourceUrl).origin + playUrl;
                }
                getM3uResource(sUrl).then(resolve, reject);
              }
            });
          })
          .catch(reject);
      });
    }

    /**
     * @desc 解析m3u播放列表
     * @params {String} txt
     * @retrns {Array}
     */
    function parseM3uPlayListTxt(txt) {
      const txts = txt.split("\n").filter((v) => !!v);
      const playList = [];
      let i = 0,
        step = 1;
      while (i < txts.length) {
        const str1 = txts[i];
        const str2 = txts[i + 1];
        if (str1.indexOf("#EXTINF") >= 0) {
          playList.push({
            duration: Number(str1.split(":")[1].replace(",", "")),
            url: str2,
          });
          i += step;
        }
        i += step;
      }
      return playList;
    }

    /**
     * @desc 解析m3u txt
     * @params {String} txt
     * @retrns {Array}
     */
    function parseM3uTxt(txt) {
      const txts = txt.split("\n").filter((v) => !!v);
      const tExt = txts.splice(0, 1);
      const sourceUrls = [];
      let i = 0;
      while (i < txts.length) {
        const [PROGRAMID, BANDWIDTH, RESOLUTION] = txts[i]
          .split(",")
          .map((v) => v.substring(v.indexOf("=") + 1));
        sourceUrls.push({
          url: txts[i + 1],
          id: Number(PROGRAMID),
          bandwidth: Number(BANDWIDTH),
          resolution: RESOLUTION,
        });
        i += 2;
      }
      return sourceUrls;
    }

    /**
     * @desc 获取链接扩展名 会转为小写字符
     * @params {String} str
     * @retrns {String}
     */
    function getSrcExt(str) {
      if (!str) {
        return "";
      }
      return (str.split(".").slice(-2)[1] || "").toLowerCase();
    }

    window.addEventListener("load", function () {
      init();
    });
  </script>
</html>
