<!-- @format -->

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link
			rel="stylesheet"
			href="https://at.alicdn.com/t/font_1805033_dzqd0ryrki9.css"
		/>
		<title>Video</title>
	</head>
	<style>
		body,
		html,
		ul,
		li {
			padding: 0;
			margin: 0;
		}

		ul,
		li {
			line-height: 0;
		}

		.flex {
			display: flex;
			display: -webkit-flex;
		}

		.video-area {
			width: 650px;
			max-width: 100%;
			height: auto;
			position: relative;
			margin: 10px 0;
		}

		.video-area video {
			width: 100%;
		}

		.video-controls {
			position: absolute;
			width: 100%;
			height: 48px;
			left: 0;
			bottom: 0;
			padding: 0 15px;
			font-size: 13px;
			color: white;
			/* background-color: rgba(0, 0, 0, 0.25);   */
			/* box-shadow: inset 0px -10px 10px 0px #333; */
			box-sizing: border-box;
			/* visibility: hidden; */
		}

		.video-area:hover .video-controls {
			visibility: visible;
		}

		.video-controls .controls {
			width: 100%;
			align-items: center;
		}

		.video-controls .controls .time {
			flex: 1;
		}

		.video-controls .progress {
			position: relative;
			width: 100%;
			height: 8px;
			margin: 6px 0;
			background-color: rgb(173, 173, 173, 0.65);
			border-radius: 4px;
			/* overflow: hidden; */
			cursor: pointer;
		}
		.video-controls .progress:hover .anchor {
			visibility: visible;
		}

		.video-controls .progress .anchor {
			position: absolute;
			padding: 2px 6px;
			left: 250px;
			bottom: 10px;
			font-size: 13px;
			color: transparent;
			user-select: none;
			visibility: hidden;
		}

		.video-controls .progress .bar {
			position: absolute;
			left: 0;
			bottom: 0;
			right: 100%;
			top: 0;
			border-radius: 4px;
			background-color: rgba(255, 255, 255, 1);
		}

		.video-controls .progress .anchor::after {
			content: attr(title);
			display: inline-block;
			position: absolute;
			bottom: 9px;
			left: 0;
			padding: 2px 6px;
			background-color: rgba(255, 255, 255, 0.8);
			color: #333;
			border-radius: 3px;
		}

		.video-controls .progress .anchor::before {
			content: '';
			position: absolute;
			width: 0;
			height: 0;
			bottom: -3px;
			left: 50%;
			transform: translateX(-50%);
			border: 6px solid;
			border-color: rgba(255, 255, 255, 0.8) transparent transparent;
		}

		.video-controls .iconfont {
			margin: 0 10px;
			font-size: 20px;
		}
	</style>

	<body>
		<div class="video-area">
			<video
				id="video"
				src="http://hls.cntv.lxdns.com/asp/hls/main/0303000a/3/default/978a64ddd3a1caa85ae70a23414e6540/main.m3u8"
			></video>
			<div class="video-controls">
				<div class="controls flex">
					<i id="play" class="iconfont iconplay"></i>
					<div class="time">
						<span id="current-time">0:00</span>
						<span id="total-time">0:00</span>
					</div>
					<i class="iconfont iconvolume-up"></i>
					<i
						class="iconfont iconFullScreen"
						style="font-weight: bold;"
					></i>
				</div>
				<div class="progress">
					<div class="anchor" title="0:00">0:00</div>
					<div class="bar"></div>
				</div>
			</div>
		</div>
	</body>

	<script src="./utils/mux.min.js"></script>
	<!-- util -->
	<script>
		const util = {
			// 是否是url
			isUrl: function (url) {
				try {
					new URL(url)
					return true
				} catch (error) {
					return false
				}
			},
			// 获取url相关信息
			getUrlInfos: function (url) {
				try {
					return new URL(url)
				} catch (error) {
					return null
				}
			},
		}
	</script>
	<!-- main -->
	<script>
		const M3U = 'm3u'
		const M3U8 = 'm3u8'
		const videoEl = document.querySelector('#video')
		const PLAY_CONFIG = {
			loadTime: 5, // 单位秒
			loadAll: false, // 是否全部加载
		}

		let totalTimes = 0

		// _init
		function _init() {
			const currentSrc = videoEl.currentSrc
			const srcExt = getSrcExt(currentSrc)
			if (srcExt === M3U || srcExt === M3U8) {
				getM3uResource(currentSrc)
					.then((sourceUrls) => {
						// console.log({ ...sourceUrls });
						handlePlay(sourceUrls)
					})
					.catch(console.warn)
			}
		}

		/**
		 * @desc 视频播放
		 * @params {Array} segments
		 *
		 */
		function handlePlay(segments = []) {
			if (!segments || !segments.length) {
				return
			}
			// source append lock
			let _appendLock = false,
				// load next segment lock
				_loadLock = false,
				// video totalTimes
				_totalTimes = 0
			// segments buffer queue
			const bufferQueue = []
			// 流文件时间区间
			const timeinterval = segments.map((v) => v.duration)
			timeinterval.map((_, i) => {
				timeinterval[i] = timeinterval[i] + (timeinterval[i - 1] || 0)
			})

			totalTimes = _totalTimes = timeinterval.slice(-1)[0]

			/** 更新播放组件相关 **/
			setVideoTotalTime(_totalTimes)

			// Replace this value with your files codec info
			const mime = 'video/mp4; codecs="mp4a.40.2,avc1.64001f"'
			const mediaSource = new MediaSource()
			const transmuxer = new muxjs.mp4.Transmuxer()

			videoEl.src = URL.createObjectURL(mediaSource)
			mediaSource.addEventListener('sourceopen', appendFirstSegment)
			// MediaElement相关事件 https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement
			videoEl.addEventListener('timeupdate', handleVideoTimeUpdate)

			function handleVideoTimeUpdate() {
				const currentTime = videoEl.currentTime
				const duration = videoEl.duration
				const canLoad = duration - currentTime < PLAY_CONFIG.loadTime
				/** 更新视频播放时间 **/
				updateVideoCurrentTime(currentTime)
				/** 更新进度 **/
				updateVideoProgress(currentTime, _totalTimes)

				/** load lock **/
				if (_loadLock) {
					return
				}

				if (canLoad) {
					_loadLock = true
					appendNextSegment()
				}
			}

			/**
			 * @desc 处理sourceBuffer append
			 **/
			function handleSourceBufferAppend() {
				// console.log("[_appendLock]:", _appendLock);
				while (bufferQueue.length) {
					try {
						if (_appendLock) {
							return
						}
						sourceBuffer.appendBuffer(
							new Uint8Array(bufferQueue[0])
						)
						bufferQueue.shift()
					} catch (error) {
						console.warn('[error]:', error)
						break
					}
				}
			}

			/**
			 * @desc 添加第一个节点
			 **/
			function appendFirstSegment() {
				// 释放一个之前已经存在的、通过调用
				URL.revokeObjectURL(videoEl.src)
				// 设置媒体duration为0 否则后面视频获取duration会出现Infinity
				mediaSource.duration = 0
				// addSourceBuffer  mime
				sourceBuffer = mediaSource.addSourceBuffer(mime)
				// sourceBuffer.addEventListener("updateend", appendNextSegment);

				transmuxer.on('data', (segment) => {
					let data = new Uint8Array(
						segment.initSegment.byteLength + segment.data.byteLength
					)
					data.set(segment.initSegment, 0)
					data.set(segment.data, segment.initSegment.byteLength)
					// debug inspect
					// console.log(muxjs.mp4.tools.inspect(data));
					sourceBuffer.appendBuffer(data)
				})

				fetch(segments.shift().sourceUrl)
					.then((response) => {
						return response.arrayBuffer()
					})
					.then((response) => {
						transmuxer.push(new Uint8Array(response))
						transmuxer.flush()
					})
				// play
				// videoEl.play();
			}

			/**
			 * @desc 添加下一个节点
			 **/
			function appendNextSegment() {
				// reset the 'data' event listener to just append (moof/mdat) boxes to the Source Buffer
				transmuxer.off('data')
				transmuxer.on('data', (segment) => {
					bufferQueue.push(segment.data)
					_appendLock = sourceBuffer.updating
					_loadLock = false
					handleSourceBufferAppend()
				})

				if (segments.length === 0) {
					// notify MSE that we have no more segments to append.
					mediaSource.endOfStream()
					return
				}

				// fetch the next segment from the segments array and pass it into the transmuxer.push method
				fetch(segments.shift().sourceUrl)
					.then((response) => response.arrayBuffer())
					.then((response) => {
						transmuxer.push(new Uint8Array(response))
						transmuxer.flush()
					})
			}
		}

		/**
		 * @desc 获取资源
		 * @params {String} txt
		 */
		function sourceCanPlay(txt) {
			if (
				txt.indexOf('#EXTINF') !== -1 &&
				txt.indexOf('#EXT-X-ENDLIST') !== -1
			) {
				return true
			}
			return false
		}

		/**
		 * @desc 获取资源
		 * @params {String} sourceUrl
		 */
		function getM3uResource(sourceUrl) {
			return new Promise((resolve, reject) => {
				fetch(sourceUrl)
					.then((response) => {
						// console.log(response);
						response.text().then((t) => {
							if (sourceCanPlay(t)) {
								const playList = parseM3uPlayListTxt(t)
								;(playList || []).map((p) => {
									if (util.isUrl(p.url)) {
										p.sourceUrl = p.url
									} else {
										p.sourceUrl = sourceUrl.replace(
											/\w+.m3u8/,
											p.url
										) // soruce url
									}
									return p
								})
								resolve(playList)
							} else {
								const sources = parseM3uTxt(t)
								let sUrl
								// TODO: 根据当前带宽自动播放,如果只有一条播放源则不用选择
								const playUrl = sources[4].url
								if (util.isUrl(playUrl)) {
									sUrl = playUrl
								} else {
									sUrl =
										util.getUrlInfos(sourceUrl).origin +
										playUrl
								}
								getM3uResource(sUrl).then(resolve, reject)
							}
						})
					})
					.catch(reject)
			})
		}

		/**
		 * @desc 解析m3u播放列表
		 * @params {String} txt
		 * @retrns {Array}
		 */
		function parseM3uPlayListTxt(txt) {
			const txts = txt.split('\n').filter((v) => !!v)
			const playList = []
			let i = 0,
				step = 1
			while (i < txts.length) {
				const str1 = txts[i]
				const str2 = txts[i + 1]
				if (str1.indexOf('#EXTINF') >= 0) {
					playList.push({
						duration: Number(str1.split(':')[1].replace(',', '')),
						url: str2,
					})
					i += step
				}
				i += step
			}
			return playList
		}

		/**
		 * @desc 解析m3u txt
		 * @params {String} txt
		 * @retrns {Array}
		 */
		function parseM3uTxt(txt) {
			const txts = txt.split('\n').filter((v) => !!v)
			const tExt = txts.splice(0, 1)
			const sourceUrls = []
			let i = 0
			while (i < txts.length) {
				const [PROGRAMID, BANDWIDTH, RESOLUTION] = txts[i]
					.split(',')
					.map((v) => v.substring(v.indexOf('=') + 1))
				sourceUrls.push({
					url: txts[i + 1],
					id: Number(PROGRAMID),
					bandwidth: Number(BANDWIDTH),
					resolution: RESOLUTION,
				})
				i += 2
			}
			return sourceUrls
		}

		/**
		 * @desc 获取链接扩展名 会转为小写字符
		 * @params {String} str
		 * @retrns {String}
		 */
		function getSrcExt(str) {
			if (!str) {
				return ''
			}
			return (str.split('.').slice(-2)[1] || '').toLowerCase()
		}

		window.addEventListener('load', function () {
			_init()
		})
	</script>

	<!-- view -->
	<script>
		const videoAreaEl = document.querySelector('.video-area')
		const playEl = document.querySelector('.video-controls #play')
		const totalTimeEl = document.querySelector(
			'.video-controls #total-time'
		)
		const currentTimeEl = document.querySelector(
			'.video-controls #current-time'
		)
		const progressEl = document.querySelector('.video-controls .progress')
		const progressBarEl = document.querySelector(
			'.video-controls .progress .bar'
		)
		const progressAnchorEl = document.querySelector(
			'.video-controls .progress .anchor'
		)
		const fullScreenEl = document.querySelector(
			'.video-controls .iconFullScreen'
		)

		/** event start **/
		progressEl.addEventListener('mousemove', handleProgressMousemove)
		progressEl.addEventListener('click', handleProgressClick)
		playEl.addEventListener('click', togglePlay)
		fullScreenEl.addEventListener('click', toggleFullScreen)

		/** 播放按钮 **/
		function togglePlay() {
			const className = playEl.className
			const iconPlay = 'iconplay'
			const iconPause = 'iconpause'
			if (className.indexOf('iconplay') >= 0) {
				playEl.className = className.replace(iconPlay, iconPause)
				videoEl.play()
			} else {
				playEl.className = className.replace(iconPause, iconPlay)
				videoEl.pause()
			}
		}
		/** 全屏按钮 **/
		function toggleFullScreen() {
			/** 全屏**/
			function requestFullscreen(docElm) {
				//W3C
				if (docElm.requestFullscreen) {
					return docElm.requestFullscreen()
				}
				//FireFox
				else if (docElm.mozRequestFullScreen) {
					return docElm.mozRequestFullScreen()
				}
				//Chrome等
				else if (docElm.webkitRequestFullScreen) {
					return docElm.webkitRequestFullScreen()
				}
				//IE11
				else if (docElm.msRequestFullscreen) {
					return docElm.msRequestFullscreen()
				}
			}
			/** 退出全屏 **/
			function cancelFullScreen() {
				if (document.exitFullscreen) {
					document.exitFullscreen()
				} else if (document.mozCancelFullScreen) {
					document.mozCancelFullScreen()
				} else if (document.webkitCancelFullScreen) {
					document.webkitCancelFullScreen()
				} else if (document.msExitFullscreen) {
					document.msExitFullscreen()
				}
			}

			if (isVideoInFullscreen()) {
				cancelFullScreen()
			} else {
				requestFullscreen(videoEl).then(() => {
					console.log('requestFullscreen')
					videoAreaEl.style.width = videoEl.clientWidth + 'px'
					videoAreaEl.style.height = videoEl.clientHeight + 'px'
					videoAreaEl.style.margin = 0
				})
			}
		}

		/** 视频处于全屏状态 **/
		function isVideoInFullscreen() {
			if (
				document.fullscreenElement &&
				document.fullscreenElement.nodeName == 'VIDEO'
			) {
				return true
			}
			return false
		}

		/** 进度条移动时间 **/
		function handleProgressMousemove(e) {
			const { layerX } = e
			const time = getTime((layerX / progressEl.clientWidth) * totalTimes)
			progressAnchorEl.title = time
			progressAnchorEl.innerHTML = time
			progressAnchorEl.style.left =
				layerX - progressAnchorEl.clientWidth / 2 + 'px'
		}

		/** 点击进度条 执行进度操作**/
		function handleProgressClick(e) {
			const { layerX } = e
			const jumpTimes = (layerX / progressEl.clientWidth) * totalTimes
			// 如果跳转的失常大于视频总时长则需要获取视频流
			if (jumpTimes > videoEl.duration) {
				// TODO: 跳转市场大于当前时长时获取视频流
			} else {
				videoEl.currentTime = jumpTimes
			}
			// 如果点击后处于暂停状态则播放
			if (videoEl.paused) {
				videoEl.play()
			}
		}

		/** 视频总时长 **/
		function setVideoTotalTime(time) {
			totalTimeEl.innerHTML = getTime(time)
		}
		/** 更新视频播放时间 **/
		function updateVideoCurrentTime(time) {
			if (videoEl.ended) {
				togglePlay()
			}
			currentTimeEl.innerHTML = getTime(time)
		}
		/** 更新播放进度 **/
		function updateVideoProgress(currtTime, totalTimes) {
			let progress = 1 - currtTime / totalTimes
			progress = progress > 0 ? progress : 0
			progressBarEl.style.right = `${progress * 100}%`
		}

		/** 获取时间 格式 mm:ss **/
		function getTime(time) {
			time = time || 0
			let m, s
			m = Math.floor(time / 60)
			s = Math.ceil(time % 60)

			return `${m}:${s > 9 ? s : '0' + s}`
		}
	</script>
</html>
