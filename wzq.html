<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>WZQ</title>
  </head>

  <body>
    <canvas
      id="wzq"
      style="margin: 0 auto; background-color: #e4c089;"
    ></canvas>
  </body>
  <script>
    // class coord
    class Coord {
      constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
      }

      inverseCoord() {
        return {
          x: 0 - this.x,
          y: 0 - this.y,
        };
      }
    }

    /** base **/
    const canvas = document.getElementById("wzq");
    const ctx = canvas.getContext("2d");
    const lines = 30;
    const qSize = 450;
    const chessSize = 12;
    const cellH = qSize / lines;
    let currentChess, chessboard, chessHistory;
    reset();
    const canvasEl = document.querySelector("#wzq");
    canvasEl.addEventListener("click", tap); //tap

    // reset
    function reset() {
      /** chess  current chess**/
      // currentChess = {
      //   step: 0,
      //   playerType: null,
      //   x: 0,
      //   y: 0,
      // };
      currentChess = new Coord();
      currentChess.step = 0;
      currentChess.playerType = null;

      // chess board
      chessboard = new Array(lines);
      chessHistory = [];
      /** main **/
      this.drawChessBoard();
    }

    // draw chess board
    function drawChessBoard() {
      canvas.width = qSize;
      canvas.height = qSize;
      ctx.fillStyle = "#000";
      ctx.lineWidth = 1.0;
      ctx.beginPath();
      ctx.lineTo(0, 0);
      ctx.lineTo(0, qSize);
      ctx.lineTo(qSize, qSize);
      ctx.lineTo(qSize, 0);
      ctx.closePath();
      for (let i = 0; i < lines; i++) {
        const cellDx = cellH * i;
        ctx.moveTo(0, cellDx);
        ctx.lineTo(qSize, cellDx);
        ctx.moveTo(cellDx, 0);
        ctx.lineTo(cellDx, qSize);
      }
      ctx.stroke();
    }

    function tap(e) {
      const { layerX, layerY } = e;
      const xIndex = Math.floor((layerX + cellH / 2) / cellH);
      const yIndex = Math.floor((layerY + cellH / 2) / cellH);
      currentChess.playerType =
        currentChess.step % 2 === 0
          ? chessPlayerType.black
          : chessPlayerType.white;
      currentChess.x = xIndex;
      currentChess.y = yIndex;

      if (!canDrawChess()) {
        return;
      }

      drawChess();
      record();
      checkVictory();
      currentChess.step++; // step ++
    }

    const chessPlayerType = {
      black: "_BLACK_",
      white: "_WHITE_",
    };

    /**
     * @desc can draw
     * @returns {Bool}
     */
    function canDrawChess() {
      const { x, y } = currentChess;
      // if draw
      if (chessboard[x] && chessboard[x][y]) {
        return false;
      }

      return true;
    }

    // draw chess
    function drawChess() {
      const { x, y, playerType } = currentChess;
      const color = playerType === chessPlayerType.black ? "black" : "white";
      ctx.fillStyle = color;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(cellH * x, cellH * y, chessSize / 2, 0, 2 * Math.PI);
      ctx.fill();
      ctx.restore();
    }

    /** record chess **/
    function record() {
      const { x, y, playerType } = currentChess;
      if (!chessboard[x]) {
        chessboard[x] = new Array(lines);
      }
      chessboard[x][y] = playerType;
      chessHistory.push(new Coord(x, y));
    }

    /**
     *
     * @desciption direction 8
     * @desciption 1.left 2.leftTop 3.top 4.rightTop 5.right 6.bottomRight 7.bottom 8.bottomLeft
     *
     **/
    const directions = {
      left: new Coord(-1, 0),
      leftTop: new Coord(-1, -1),
      top: new Coord(0, -1),
      rightTop: new Coord(1, -1),
      // right: new Coord(1, 0),
      // bottomRight: new Coord(1, 1),
      // bottom: new Coord(0, 1),
      // bottomLeft: new Coord(-1, 1),
    };
    const _directions2 = [
      {
        prev: directions.left,
        next: directions.left.inverseCoord(),
      },
      {
        prev: directions.leftTop,
        next: directions.leftTop.inverseCoord(),
      },
      {
        prev: directions.top,
        next: directions.top.inverseCoord(),
      },
      {
        prev: directions.rightTop,
        next: directions.rightTop.inverseCoord(),
      },
    ];

    // 计算棋子
    function getConnectCount(offsetCoord) {
      const { x, y, playerType } = currentChess;
      let count = 0;
      const check = (currentCoord) => {
        const cx = currentCoord.x + offsetCoord.x;
        const cy = currentCoord.y + offsetCoord.y;
        if (!chessboard[cx]) {
          return count;
        }
        if (chessboard[cx][cy] === playerType) {
          count++;
          // tips x,y
          check({
            x: cx,
            y: cy,
          });
        } else {
          return;
        }
      };
      check({ x, y });
      return count;
    }

    /** check victory **/
    function checkVictory() {
      const { playerType } = currentChess;
      for (const { prev, next } of _directions2) {
        const cCount = getConnectCount(prev) + getConnectCount(next) + 1;
        if (cCount > 4) {
          confirm(`${playerType} victory,congrations!`);
          reset();
          break;
        }
      }
    }
  </script>
</html>
