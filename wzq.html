<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>WZQ</title>
  </head>

  <style>
    body {
      margin: 0;
      padding: 0;
    }
    .container {
      width: 100vw;
      height: 100vh;
      text-align: center;
      background-color: #ececec;
      overflow: hidden;
    }
    #wzq {
      background-color: #e4c089;
    }
    button {
      width: 150px;
      text-align: center;
      font-size: 1.3em;
      cursor: pointer;
    }
  </style>

  <body>
    <div class="container">
      <h3 id="title">黑棋先手</h3>
      <canvas id="wzq"></canvas>
      <h4 id="currentPlayer"></h4>
      <div>
        <button id="regret">悔棋</button>
        <button id="replay">重新开始</button>
      </div>
    </div>
  </body>
  <!-- common -->
  <script>
    // class coord
    class Coord {
      constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
      }

      inverseCoord() {
        return {
          x: 0 - this.x,
          y: 0 - this.y,
        };
      }
    }

    class MyJQ {
      constructor(selector) {
        this.selector = selector;
        this.el = document.querySelector(selector);
      }
      innerHTML(val) {
        this.el.innerHTML = val;
        return this;
      }

      click(cb) {
        if ("function" === typeof cb) {
          this.el.addEventListener("click", cb);
        }
        return this;
      }
    }

    // inject my JQ
    function inject(selector) {
      try {
        return new MyJQ(selector);
      } catch (error) {
        console.log("Error", error);
      }
    }

    // my JQ
    const $ = inject;
  </script>

  <script>
    /** constant  **/
    const chessPlayerType = {
      black: "_BLACK_",
      white: "_WHITE_",
    };

    const chessColor = {
      [chessPlayerType.black]: "black",
      [chessPlayerType.white]: "white",
    };

    const I18n = {
      en: {},
      "zh-cn": {
        [chessPlayerType.black]: "黑棋",
        [chessPlayerType.white]: "白棋",
        currentChessPlayer: "当前棋手",
        regret: "是否确定悔棋？",
        replay: "是否确定重新开始？",
        emptyChessBoard: "没有可反悔的棋子！",
        congrations: "胜利了，恭喜！！",
        pleaseReplay: "请重新开始游戏。",
      },
    };

    /** base **/
    const canvas = document.getElementById("wzq");
    const ctx = canvas.getContext("2d");
    const lines = 30; // 棋盘线
    const qSize = 550; // 棋盘大小
    const chessSize = 14; // 棋子大小
    const cellH = qSize / lines;
    const currentChess = new Coord();
    let chessboard, chessHistory, isVictory;
    // i18n
    const local = I18n["zh-cn"];
    const canvasEl = document.querySelector("#wzq");
    // reset
    reset();
    //tap
    canvasEl.addEventListener("click", tap);
    // regret
    $("#regret").click(() => {
      if (isVictory) {
        alert(local.pleaseReplay);
        return;
      }

      if (!chessHistory.length) {
        alert(local.emptyChessBoard);
        return;
      }

      if (confirm(local.regret)) {
        handleRegret();
      }
    });
    // replay
    $("#replay").click(() => {
      if (confirm(local.replay)) {
        reset();
      }
    });

    function tap(e) {
      // if victory
      if (!!isVictory) {
        return;
      }
      const { layerX, layerY } = e;
      // const xIndex = Math.floor((layerX + cellH / 2) / cellH);
      // const yIndex = Math.floor((layerY + cellH / 2) / cellH);
      const chessCoord = getChessCoord(layerX, layerY);
      currentChess.playerType =
        currentChess.step % 2 === 0
          ? chessPlayerType.black
          : chessPlayerType.white;
      currentChess.x = chessCoord.x;
      currentChess.y = chessCoord.y;

      if (!canDrawChess()) {
        return;
      }
      // draw chess
      drawChess(chessCoord, chessColor[currentChess.playerType], chessSize);
      record();
      showPlayer();
      if (checkVictory()) {
        isVictory = true;
        showVictory();
      } else {
        // step ++
        currentChess.step++;
      }
    }

    /**
     * @desc get chess coord
     * @desc 获取棋子的坐标（根据位置）
     *
     */
    function getChessCoord(layerX, layerY) {
      const x = Math.floor((layerX + cellH / 2) / cellH);
      const y = Math.floor((layerY + cellH / 2) / cellH);
      return new Coord(x, y);
    }

    // reset
    function reset() {
      /** chess  current chess**/
      currentChess.step = 0;
      currentChess.playerType = null;
      isVictory = false;
      // chess board
      chessboard = new Array(lines);
      chessHistory = [];
      /** main **/
      drawChessBoard();
      drawChessBoardCenter();
      showPlayer();
    }

    /**
     * @desc draw center
     * @desc 画棋盘中心点(5个位置)
     *
     */
    function drawChessBoardCenter() {
      const centerCoord = getChessCoord(qSize / 2, qSize / 2);
      const offsetLeftTop = new Coord(-5, -5);
      const offsetRightTop = new Coord(5, -5);
      const fixedPoints = [
        offsetLeftTop,
        offsetLeftTop.inverseCoord(),
        offsetRightTop,
        offsetRightTop.inverseCoord(),
      ];

      for (const item of fixedPoints) {
        const x = centerCoord.x + item.x;
        const y = centerCoord.y + item.y;
        drawChess(new Coord(x, y), "#333", 8);
      }

      drawChess(centerCoord, "#333", 8);
    }

    /**
     * @desc handle regret
     * @desc 悔棋需要判断是哪方在悔棋
     * @desc 由于现在没有做联机 所以不需要做太复杂，只能反悔当前这颗棋子(可连续悔棋)
     */
    function handleRegret() {
      // delete history
      chessboard[currentChess.x][currentChess.y] = null;
      chessHistory.pop();
      // repaint chess board
      drawChessBoard();
      // draw Center
      drawChessBoardCenter();
      // draw chess
      for (const chessCoord of chessHistory) {
        currentChess.x = chessCoord.x;
        currentChess.y = chessCoord.y;
        currentChess.playerType = chessboard[chessCoord.x][chessCoord.y];
        drawChess(chessCoord, chessColor[currentChess.playerType], chessSize);
      }
      // step --
      currentChess.step--;
      // show player
      showPlayer();
    }

    // draw chess board
    function drawChessBoard() {
      canvas.width = qSize;
      canvas.height = qSize;
      ctx.fillStyle = "#000";
      ctx.lineWidth = 1.0;
      ctx.beginPath();
      ctx.lineTo(0, 0);
      ctx.lineTo(0, qSize);
      ctx.lineTo(qSize, qSize);
      ctx.lineTo(qSize, 0);
      ctx.closePath();
      for (let i = 0; i < lines; i++) {
        const cellDx = cellH * i;
        ctx.moveTo(0, cellDx);
        ctx.lineTo(qSize, cellDx);
        ctx.moveTo(cellDx, 0);
        ctx.lineTo(cellDx, qSize);
      }
      ctx.stroke();
    }

    /**
     * @desc show page player
     *
     **/
    function showPlayer() {
      try {
        let { playerType } = currentChess;
        let innerTxt = `${local.currentChessPlayer}：-`;
        if (playerType) {
          playerType =
            chessPlayerType.black === playerType
              ? chessPlayerType.white
              : chessPlayerType.black;
          innerTxt = `${local.currentChessPlayer}：${local[playerType]}`;
        }
        $("#currentPlayer").innerHTML(innerTxt);
      } catch (error) {}
    }

    /**
     * @desc show victory
     *
     **/
    function showVictory() {
      const { playerType } = currentChess;
      $("#title").innerHTML(`${local[playerType]}${local.congrations}`);
    }

    /**
     * @desc can draw
     * @returns {Bool}
     */
    function canDrawChess() {
      const { x, y } = currentChess;
      // if draw
      if (chessboard[x] && chessboard[x][y]) {
        return false;
      }

      return true;
    }

    /**
     * @desc draw chess
     * @params {Coord} chessCoord
     * @params {Color} color
     * @params {int} size
     **/
    function drawChess(chessCoord, color, size) {
      // const { x, y, playerType } = currentChess;
      // ctx.fillStyle = chessColor[playerType];
      ctx.fillStyle = color;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(
        cellH * chessCoord.x,
        cellH * chessCoord.y,
        size / 2,
        0,
        2 * Math.PI
      );
      ctx.fill();
      ctx.restore();
    }

    /** record chess **/
    function record() {
      const { x, y, playerType } = currentChess;
      if (!chessboard[x]) {
        chessboard[x] = new Array(lines);
      }
      chessboard[x][y] = playerType;
      chessHistory.push(new Coord(x, y));
    }

    /**
     *
     * @desciption direction 8
     * @desciption 1.left 2.leftTop 3.top 4.rightTop 5.right 6.bottomRight 7.bottom 8.bottomLeft
     *
     **/
    const directions = {
      left: new Coord(-1, 0),
      leftTop: new Coord(-1, -1),
      top: new Coord(0, -1),
      rightTop: new Coord(1, -1),
      // right: new Coord(1, 0),
      // bottomRight: new Coord(1, 1),
      // bottom: new Coord(0, 1),
      // bottomLeft: new Coord(-1, 1),
    };
    const _directions2 = [
      {
        prev: directions.left,
        next: directions.left.inverseCoord(),
      },
      {
        prev: directions.leftTop,
        next: directions.leftTop.inverseCoord(),
      },
      {
        prev: directions.top,
        next: directions.top.inverseCoord(),
      },
      {
        prev: directions.rightTop,
        next: directions.rightTop.inverseCoord(),
      },
    ];

    // 计算棋子
    function getConnectCount(offsetCoord) {
      const { x, y, playerType } = currentChess;
      let count = 0;
      const check = (currentCoord) => {
        const cx = currentCoord.x + offsetCoord.x;
        const cy = currentCoord.y + offsetCoord.y;
        if (!chessboard[cx]) {
          return count;
        }
        if (chessboard[cx][cy] === playerType) {
          count++;
          // tips x,y
          check({
            x: cx,
            y: cy,
          });
        } else {
          return;
        }
      };
      check({ x, y });
      return count;
    }

    /**
     * @desc check victory
     * @returns {Bool} true -> victory false-> continiue
     */
    function checkVictory() {
      const { playerType } = currentChess;
      for (const { prev, next } of _directions2) {
        const cCount = getConnectCount(prev) + getConnectCount(next) + 1;
        if (cCount > 4) {
          return true;
        }
      }
      return false;
    }
  </script>
</html>
